# Software Design for ML service
## Задание №1 Объектная модель сервиса.
- созданы классы объектной модели сервиса,
- функционал может дополняться и изменяться,
- на части классов стоит заглушка pass до того момента, когда будет выбран функционал.

Созданы две роли для юзеров: обычный пользователь и админ.
Пользователь по умолчанию: обычный пользователь с бонусным счётом кредитов.

В качестве примера созданы два пользователя: обычный пользователь c бонусным счётом кредитов по умолчанию и второй пользователь - админ.

В папке log находится информация по первому и второму пользователю:
- в первом случае на счёт пользователя записался бонусный счёт кредит по умолчанию,
- во втором случае явно указали, что пользователь - админ.
## Задание №2 Запуск и эксплуатация сервиса. Часть1.
- структурно организован проект (создана папка app, в неё согласно предполагаемого функционала распределены классы объектной модели сервиса в модули Python и логирование),
- написан docker-compose файл с 4 сервисами app, web-proxy, rabbitmq, database с определённой функциональностью, согласно заданию.
## Задание №3 Хранение данных.
- ветка для этого задания сделана от ветки предыдущего задания, чтобы следить за изменениями проекта
- на определённом этапе стоит перенести разработку в develop ветку, делая небольшие hotfix'ы (и/или) задания
- изменена структура проекта для удобной работы с SQLmodel
- классы объектной модели сервиса подключены к базе данных с использованием SQLmodel
- продумана структура таблиц, в частности таблица отвечающая за транзакции связана через внешней ключ с таблицей представляющей модель пользователя
- в таблице пользователя задан булевый тип admin_role, который отвечает за то, является ли пользователь админом (у нас две роли). В случае большего количества ролей следует UserRole подключить к SQLmodel, поэтому ./models/user_role.py оставляем для расширения функционала, увеличения ролей
- в файле docker-compose.yml часть команд закомментирована или изменена, поскольку предыдущее задание относится к будущему функционалу сервиса 
- с помощью команды docker-compose up поднимается база данных postgres и зависящее от базы данных приложение app
- при поднятии приложения выполняется скрипт main.py (пока такое название для основного скрипта) для тестирования работоспособности системы и инициализации базы данных стандартными данными: в базе данных создаются три тестовых пользователя с увеличивающимся идентификатором, с начальным не нулевым балансом на счету и без указания отчества (опциональный параметр)
- для пользователей с id=1 и id=3 создаются транзакции с разным статус кодом и балансом. У пользователя с id=1 более одной транзакции и метод, который показывает транзакции определённого пользователя отфильтрован по user_id (внешний ключ таблицы транзакций по отношению к таблице модели пользователя) выдал все транзакции только этого пользователя
- в случае если пользователя не существует или данные заполнены не верно (специально вводились не верные данные), при валидации данных ORM фреймворк выдавал ошибку, в зависимости от типа ошибки следует в дальнейшем менять поведение пользователя при заполнении форм регистрации и при работе ML-сервиса
- в файле ./log/software_design_app-1.log представлен один из логов запуска приложения с выполнением скрипта по инициализации базы данных и работоспособности системы
### Бонусные кредиты. Отдельная сущность для баланса пользователя (кредиты на счету)
- для поля UserModel.credit_amount написаны методы пополнения и списания бонусного кредита, - можно использовать помимо основного баланса. Сейчас это характеристика лояльности к пользователю, выраженная в бонусных кредитах
- прописана в SQLModel модель Balance, связывает пользователя с его балансом. Написаны и протестированы методы инициализации баланса, пополнения, списания, проверки баланса на достаточность средств для предсказания
#### Работа с переменными окружения.
- для понимания, что прописывать в '.env' запушен в гит '.env_example' с переменными окружения без заданных аргументов
---
В дальнейшем для усовершенствования сервиса следует проработать архитектуру c момента подключения api к проекту.
## Задание №4 Способы взаимодействия с пользователем.
- реализован интерфейс взаимодействия с системой - REST на FastAPI
- выбран Telegram bot, где также будет реализован проект. Реализуется взаимодействие с системой через телеграм бот
- наименование endpoint для RESTful API сделано интутитивным
- генерируется и используется JWT-токен при работе пользователя в системе
- хороший материал, как использовать JWT-токен для дальнейшей разработки [здесь](https://habr.com/ru/articles/829742/)
(дополнительно описано, как разным пользователям дать разные права, установить время жизни токена)
для аутентификации пользователя в методах применяется подтверждение доступа по токену.
## Задание №5 Способы взаимодействия с ML сервисами.
- реализовано подключение модели, обрабатывающее фото к RabbitMQ
- изображения отправляются в виде пути к файлу через очередь input_queue
- когда сообщение с путем к изображению попадает в очередь input_queue, оно принимается программой, и начинается процесс удаления фона
- после успешной обработки результат сохраняется в файл и отправляется сообщение с результатом выполнения в очередь result_queue
- клиенты получают результат обработки, подписавшись на очередь result_queue. Это позволяет клиентам увидеть путь к сохраненному файлу с удаленным фоном
- воркеры прописаны в docker-compose.yml, одиночный воркер запускается командой rmworker_init.py, количество слушателей задается параметом scale, выбрано 4 слушателя
- воркеру при инициализации передаются параметры подключения, по умолчанию очередь для издателя называется 'input_queue', а для слушателя называется 'result_queue'
- воркеру передаётся строковое значение, - путь к исходному файлу
- добавлено сохранение результатов работы программы по обработке изображения в базу данных. Теперь, после того, как задача отработана, сохраняются пути к файлу необработанного изображения и к файлу обработанного изображения в класс Dataimage
- добавлены эндпойнт для получения результата (по user_id выдаются все данные из таблицы SQLModel DataImage)
- проверяется баланс пользователя на возможность работы с мл-моделью, после списываются средства
- перед отработкой изображения с помощью изображения происходит проверка баланса на возможность осуществления предсказания с помощью метода check_balance_sufficiency
- после обработки фотографии происходит списывание баланса на сумму AMOUNT_WITHDRAWAL_FOR_PREDICTION
- результаты работы можно получить с помощью эндпойнта @bgremover_router.get("/image/{download_path:path}") (пользователю перед этим даётся путь для скачивания обработанной фотографии и он скачивает её) Обработанная фотография, это и есть результат работы ML-модели.
## Задание №6 Web интерфейс.
- функционал взаимодействия с ядром системы происходит в streamlit.
## Задание №7 Тестирование ПО.
- обновлен файл requirements.txt для нужд тестирования (библиотеки httpx, httpcore).
- протестирована локально в контейнере докера (используя exec) с помощью pytest и TestClient работоспособность системы.
- добавлен тест, когда региструируются с email, который уже есть в базе (проверка на status_code = 400).
- добавлен тест на проверку, что итоговвая сумма после пополнения (списания) баланса равна той сумме, которая должна быть.
- добавлен тест на баланс пользователя при нулевом балансе (общая проверка работает: баланс не может быть отрицательным после списания средств).
